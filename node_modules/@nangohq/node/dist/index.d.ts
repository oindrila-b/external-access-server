import type { AxiosResponse } from 'axios';
import type { OAuth1Credentials, OAuth2Credentials, ProxyConfiguration, GetRecordsRequestConfig, ListRecordsRequestConfig, BasicApiCredentials, ApiKeyCredentials, AppCredentials, Metadata, Connection, ConnectionList, Integration, IntegrationWithCreds, SyncStatusResponse, UpdateSyncFrequencyResponse, StandardNangoConfig } from './types.js';
import { AuthModes } from './types.js';
export declare const stagingHost = "https://api-staging.nango.dev";
export declare const prodHost = "https://api.nango.dev";
export * from './types.js';
interface NangoProps {
    host?: string;
    secretKey: string;
    connectionId?: string;
    providerConfigKey?: string;
    isSync?: boolean;
    dryRun?: boolean;
    activityLogId?: number;
}
interface CreateConnectionOAuth1 extends OAuth1Credentials {
    connection_id: string;
    provider_config_key: string;
    type: AuthModes.OAuth1;
}
interface OAuth1Token {
    oAuthToken: string;
    oAuthTokenSecret: string;
}
interface CreateConnectionOAuth2 extends OAuth2Credentials {
    connection_id: string;
    provider_config_key: string;
    type: AuthModes.OAuth2;
}
export declare enum SyncType {
    INITIAL = "INITIAL",
    INCREMENTAL = "INCREMENTAL"
}
export interface SyncResult {
    added: number;
    updated: number;
    deleted: number;
}
export interface NangoSyncWebhookBody {
    connectionId: string;
    providerConfigKey: string;
    syncName: string;
    model: string;
    responseResults: SyncResult;
    syncType: SyncType;
    queryTimeStamp: string | null;
    modifiedAfter: string | null;
}
export type LastAction = 'ADDED' | 'UPDATED' | 'DELETED';
export interface RecordMetadata {
    first_seen_at: string;
    last_seen_at: string;
    last_action: LastAction;
    deleted_at: string | null;
    cursor: string;
}
export declare class Nango {
    serverUrl: string;
    secretKey: string;
    connectionId?: string;
    providerConfigKey?: string;
    isSync: boolean;
    dryRun: boolean;
    activityLogId?: number;
    constructor(config: NangoProps);
    /**
     * =======
     * INTEGRATIONS
     *      LIST
     *      GET
     *      CREATE
     *      UPDATE
     *      DELETE
     * =======
     */
    listIntegrations(): Promise<{
        configs: Pick<Integration, 'unique_key' | 'provider'>[];
    }>;
    getIntegration(providerConfigKey: string, includeIntegrationCredentials?: boolean): Promise<{
        config: Integration | IntegrationWithCreds;
    }>;
    createIntegration(provider: string, providerConfigKey: string, credentials?: Record<string, string>): Promise<{
        config: Integration;
    }>;
    updateIntegration(provider: string, providerConfigKey: string, credentials?: Record<string, string>): Promise<{
        config: Integration;
    }>;
    deleteIntegration(providerConfigKey: string): Promise<AxiosResponse<void>>;
    /**
     * =======
     * CONNECTIONS
     *      LIST
     *      GET
     *      IMPORT / CREATE -- DEPRECATED use REST API
     *      GET TOKEN
     *      GET RAW TOKEN
     *      GET METADATA
     *      SET METADATA
     *      DELETE
     * =======
     */
    /**
     * Get the list of Connections, which does not contain access credentials.
     */
    listConnections(connectionId?: string): Promise<{
        connections: ConnectionList[];
    }>;
    /**
     * Get the Connection object, which also contains access credentials and full credentials payload
     * returned by the external API.
     * @param providerConfigKey - This is the unique Config Key for the integration
     * @param connectionId - This is the unique connection identifier used to identify this connection
     * @param [forceRefresh] - When set, this is used to  obtain a new refresh token from the provider before the current token has expired,
     * you can set the forceRefresh argument to true.
     * @param [refreshToken] - When set this returns the refresh token as part of the response
     */
    getConnection(providerConfigKey: string, connectionId: string, forceRefresh?: boolean, refreshToken?: boolean): Promise<Connection>;
    /**
     * @deprecated This method has been deprecated, please use the REST API to import a connection.
     */
    importConnection(_connectionArgs: CreateConnectionOAuth1 | (CreateConnectionOAuth2 & {
        metadata: string;
        connection_config: string;
    })): void;
    /**
     * @deprecated This method has been deprecated, please use the REST API to import a connection.
     */
    createConnection(_connectionArgs: CreateConnectionOAuth1 | (CreateConnectionOAuth2 & {
        metadata: string;
        connection_config: string;
    })): void;
    /**
     * For OAuth 2: returns the access token directly as a string.
     * For OAuth 2: If you want to obtain a new refresh token from the provider before the current token has expired,
     * you can set the forceRefresh argument to true."
     * For OAuth 1: returns an object with 'oAuthToken' and 'oAuthTokenSecret' fields.
     * @param providerConfigKey - This is the unique Config Key for the integration
     * @param connectionId - This is the unique connection identifier used to identify this connection
     * @param [forceRefresh] - When set, this is used to  obtain a new refresh token from the provider before the current token has expired,
     * you can set the forceRefresh argument to true.
     * */
    getToken(providerConfigKey: string, connectionId: string, forceRefresh?: boolean): Promise<string | OAuth1Token | BasicApiCredentials | ApiKeyCredentials | AppCredentials>;
    /**
     * Get the full (fresh) credentials payload returned by the external API,
     * which also contains access credentials.
     * @param providerConfigKey - This is the unique Config Key for the integration
     * @param connectionId - This is the unique connection identifier used to identify this connection
     * @param [forceRefresh] - When set, this is used to  obtain a new refresh token from the provider before the current token has expired,
     * you can set the forceRefresh argument to true.
     * */
    getRawTokenResponse<T = Record<string, any>>(providerConfigKey: string, connectionId: string, forceRefresh?: boolean): Promise<T>;
    getMetadata<T = Metadata>(providerConfigKey: string, connectionId: string): Promise<T>;
    setMetadata(providerConfigKey: string, connectionId: string, metadata: Record<string, any>): Promise<AxiosResponse<void>>;
    updateMetadata(providerConfigKey: string, connectionId: string, metadata: Record<string, any>): Promise<AxiosResponse<void>>;
    deleteConnection(providerConfigKey: string, connectionId: string): Promise<AxiosResponse<void>>;
    /**
     * =======
     * SCRIPTS
     *      CONFIG
     * =======
     */
    getScriptsConfig(): Promise<StandardNangoConfig[]>;
    /**
     * =======
     * SYNCS
     *      GET RECORDS
     *      TRIGGER
     *      START
     *      PAUSE
     *      STATUS
     *      GET ENVIRONMENT VARIABLES
     * =======
     */
    /**
     * @deprecated. Use listRecords() instead.
     */
    getRecords<T = any>(config: GetRecordsRequestConfig): Promise<(T & {
        _nango_metadata: RecordMetadata;
    })[]>;
    listRecords<T = any>(config: ListRecordsRequestConfig): Promise<{
        records: (T & {
            _nango_metadata: RecordMetadata;
        })[];
        next_cursor: string | null;
    }>;
    triggerSync(providerConfigKey: string, syncs?: string[], connectionId?: string, fullResync?: boolean): Promise<void>;
    startSync(providerConfigKey: string, syncs: string[], connectionId?: string): Promise<void>;
    pauseSync(providerConfigKey: string, syncs: string[], connectionId?: string): Promise<void>;
    syncStatus(providerConfigKey: string, syncs: '*' | string[], connectionId?: string): Promise<SyncStatusResponse>;
    updateSyncConnectionFrequency(providerConfigKey: string, sync: string, connectionId: string, frequency: string | null): Promise<UpdateSyncFrequencyResponse>;
    getEnvironmentVariables(): Promise<{
        name: string;
        value: string;
    }[]>;
    /**
     * =======
     * ACTIONS
     *      TRIGGER
     * =======
     */
    triggerAction(providerConfigKey: string, connectionId: string, actionName: string, input?: unknown): Promise<object>;
    /**
     * =======
     * PROXY
     *      GET
     *      POST
     *      PUT
     *      PATCH
     *      DELETE
     * =======
     */
    proxy<T = any>(config: ProxyConfiguration): Promise<AxiosResponse<T>>;
    get<T = any>(config: ProxyConfiguration): Promise<AxiosResponse<T>>;
    post<T = any>(config: ProxyConfiguration): Promise<AxiosResponse<T>>;
    patch<T = any>(config: ProxyConfiguration): Promise<AxiosResponse<T>>;
    delete<T = any>(config: ProxyConfiguration): Promise<AxiosResponse<T>>;
    private getConnectionDetails;
    private listConnectionDetails;
    private enrichHeaders;
}
