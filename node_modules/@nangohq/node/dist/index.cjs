"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// lib/index.ts
var lib_exports = {};
__export(lib_exports, {
  AuthModes: () => AuthModes,
  Nango: () => Nango,
  SyncConfigType: () => SyncConfigType,
  SyncType: () => SyncType,
  prodHost: () => prodHost,
  stagingHost: () => stagingHost
});
module.exports = __toCommonJS(lib_exports);
var import_axios = __toESM(require("axios"), 1);

// lib/types.ts
var AuthModes = /* @__PURE__ */ ((AuthModes2) => {
  AuthModes2["OAuth1"] = "OAUTH1";
  AuthModes2["OAuth2"] = "OAUTH2";
  AuthModes2["Basic"] = "BASIC";
  AuthModes2["ApiKey"] = "API_KEY";
  AuthModes2["AppStore"] = "APP_STORE";
  AuthModes2["Custom"] = "CUSTOM";
  AuthModes2["App"] = "APP";
  AuthModes2["None"] = "NONE";
  return AuthModes2;
})(AuthModes || {});
var SyncConfigType = /* @__PURE__ */ ((SyncConfigType2) => {
  SyncConfigType2["SYNC"] = "sync";
  SyncConfigType2["ACTION"] = "action";
  return SyncConfigType2;
})(SyncConfigType || {});

// lib/utils.ts
var validateProxyConfiguration = (config) => {
  const requiredParams = ["endpoint", "providerConfigKey", "connectionId"];
  requiredParams.forEach((param) => {
    if (typeof config[param] === "undefined") {
      throw new Error(`${param} is missing and is required to make a proxy call!`);
    }
  });
};
var validateSyncRecordConfiguration = (config) => {
  const requiredParams = ["model", "providerConfigKey", "connectionId"];
  requiredParams.forEach((param) => {
    if (typeof config[param] === "undefined") {
      throw new Error(`${param} is missing and is required to make a proxy call!`);
    }
  });
};

// lib/index.ts
var stagingHost = "https://api-staging.nango.dev";
var prodHost = "https://api.nango.dev";
var SyncType = /* @__PURE__ */ ((SyncType2) => {
  SyncType2["INITIAL"] = "INITIAL";
  SyncType2["INCREMENTAL"] = "INCREMENTAL";
  return SyncType2;
})(SyncType || {});
var Nango = class {
  serverUrl;
  secretKey;
  connectionId;
  providerConfigKey;
  isSync = false;
  dryRun = false;
  activityLogId;
  constructor(config) {
    config.host = config.host || prodHost;
    this.serverUrl = config.host;
    if (this.serverUrl.slice(-1) === "/") {
      this.serverUrl = this.serverUrl.slice(0, -1);
    }
    if (!config.secretKey) {
      throw new Error("You must specify a secret key (cf. documentation).");
    }
    try {
      new URL(this.serverUrl);
    } catch {
      throw new Error(`Invalid URL provided for the Nango host: ${this.serverUrl}`);
    }
    this.secretKey = config.secretKey;
    this.connectionId = config.connectionId || "";
    this.providerConfigKey = config.providerConfigKey || "";
    if (config.isSync) {
      this.isSync = config.isSync;
    }
    if (config.dryRun) {
      this.dryRun = config.dryRun;
    }
    if (config.activityLogId) {
      this.activityLogId = config.activityLogId;
    }
  }
  /**
   * =======
   * INTEGRATIONS
   *      LIST
   *      GET
   *      CREATE
   *      UPDATE
   *      DELETE
   * =======
   */
  async listIntegrations() {
    const url = `${this.serverUrl}/config`;
    const response = await import_axios.default.get(url, { headers: this.enrichHeaders({}) });
    return response.data;
  }
  async getIntegration(providerConfigKey, includeIntegrationCredentials = false) {
    const url = `${this.serverUrl}/config/${providerConfigKey}`;
    const response = await import_axios.default.get(url, { headers: this.enrichHeaders({}), params: { include_creds: includeIntegrationCredentials } });
    return response.data;
  }
  async createIntegration(provider, providerConfigKey, credentials) {
    const url = `${this.serverUrl}/config`;
    const response = await import_axios.default.post(url, { provider, provider_config_key: providerConfigKey, ...credentials }, { headers: this.enrichHeaders({}) });
    return response.data;
  }
  async updateIntegration(provider, providerConfigKey, credentials) {
    const url = `${this.serverUrl}/config`;
    const response = await import_axios.default.put(url, { provider, provider_config_key: providerConfigKey, ...credentials }, { headers: this.enrichHeaders({}) });
    return response.data;
  }
  async deleteIntegration(providerConfigKey) {
    const url = `${this.serverUrl}/config/${providerConfigKey}`;
    return await import_axios.default.delete(url, { headers: this.enrichHeaders({}) });
  }
  /**
   * =======
   * CONNECTIONS
   *      LIST
   *      GET
   *      IMPORT / CREATE -- DEPRECATED use REST API
   *      GET TOKEN
   *      GET RAW TOKEN
   *      GET METADATA
   *      SET METADATA
   *      DELETE
   * =======
   */
  /**
   * Get the list of Connections, which does not contain access credentials.
   */
  async listConnections(connectionId) {
    const response = await this.listConnectionDetails(connectionId);
    return response.data;
  }
  /**
   * Get the Connection object, which also contains access credentials and full credentials payload
   * returned by the external API.
   * @param providerConfigKey - This is the unique Config Key for the integration
   * @param connectionId - This is the unique connection identifier used to identify this connection
   * @param [forceRefresh] - When set, this is used to  obtain a new refresh token from the provider before the current token has expired,
   * you can set the forceRefresh argument to true.
   * @param [refreshToken] - When set this returns the refresh token as part of the response
   */
  async getConnection(providerConfigKey, connectionId, forceRefresh, refreshToken) {
    const response = await this.getConnectionDetails(providerConfigKey, connectionId, forceRefresh, refreshToken);
    return response.data;
  }
  /**
   * @deprecated This method has been deprecated, please use the REST API to import a connection.
   */
  importConnection(_connectionArgs) {
    throw new Error("This method has been deprecated, please use the REST API to import a connection.");
  }
  /**
   * @deprecated This method has been deprecated, please use the REST API to import a connection.
   */
  createConnection(_connectionArgs) {
    throw new Error("This method has been deprecated, please use the REST API to create a connection.");
  }
  /**
   * For OAuth 2: returns the access token directly as a string.
   * For OAuth 2: If you want to obtain a new refresh token from the provider before the current token has expired,
   * you can set the forceRefresh argument to true."
   * For OAuth 1: returns an object with 'oAuthToken' and 'oAuthTokenSecret' fields.
   * @param providerConfigKey - This is the unique Config Key for the integration
   * @param connectionId - This is the unique connection identifier used to identify this connection
   * @param [forceRefresh] - When set, this is used to  obtain a new refresh token from the provider before the current token has expired,
   * you can set the forceRefresh argument to true.
   * */
  async getToken(providerConfigKey, connectionId, forceRefresh) {
    const response = await this.getConnectionDetails(providerConfigKey, connectionId, forceRefresh);
    switch (response.data.credentials.type) {
      case "OAUTH2" /* OAuth2 */:
        return response.data.credentials.access_token;
      case "OAUTH1" /* OAuth1 */:
        return { oAuthToken: response.data.credentials.oauth_token, oAuthTokenSecret: response.data.credentials.oauth_token_secret };
      default:
        return response.data.credentials;
    }
  }
  /**
   * Get the full (fresh) credentials payload returned by the external API,
   * which also contains access credentials.
   * @param providerConfigKey - This is the unique Config Key for the integration
   * @param connectionId - This is the unique connection identifier used to identify this connection
   * @param [forceRefresh] - When set, this is used to  obtain a new refresh token from the provider before the current token has expired,
   * you can set the forceRefresh argument to true.
   * */
  async getRawTokenResponse(providerConfigKey, connectionId, forceRefresh) {
    const response = await this.getConnectionDetails(providerConfigKey, connectionId, forceRefresh);
    const credentials = response.data.credentials;
    return credentials.raw;
  }
  async getMetadata(providerConfigKey, connectionId) {
    if (!providerConfigKey) {
      throw new Error("Provider Config Key is required");
    }
    if (!connectionId) {
      throw new Error("Connection Id is required");
    }
    const response = await this.getConnectionDetails(providerConfigKey, connectionId, false, false, {
      "Nango-Is-Sync": true,
      "Nango-Is-Dry-Run": this.dryRun
    });
    return response.data.metadata;
  }
  async setMetadata(providerConfigKey, connectionId, metadata) {
    if (!providerConfigKey) {
      throw new Error("Provider Config Key is required");
    }
    if (!connectionId) {
      throw new Error("Connection Id is required");
    }
    if (!metadata) {
      throw new Error("Metadata is required");
    }
    const url = `${this.serverUrl}/connection/${connectionId}/metadata?provider_config_key=${providerConfigKey}`;
    const headers = {
      "Provider-Config-Key": providerConfigKey
    };
    return import_axios.default.post(url, metadata, { headers: this.enrichHeaders(headers) });
  }
  async updateMetadata(providerConfigKey, connectionId, metadata) {
    if (!providerConfigKey) {
      throw new Error("Provider Config Key is required");
    }
    if (!connectionId) {
      throw new Error("Connection Id is required");
    }
    if (!metadata) {
      throw new Error("Metadata is required");
    }
    const url = `${this.serverUrl}/connection/${connectionId}/metadata?provider_config_key=${providerConfigKey}`;
    const headers = {
      "Provider-Config-Key": providerConfigKey
    };
    return import_axios.default.patch(url, metadata, { headers: this.enrichHeaders(headers) });
  }
  async deleteConnection(providerConfigKey, connectionId) {
    const url = `${this.serverUrl}/connection/${connectionId}?provider_config_key=${providerConfigKey}`;
    const headers = {
      "Content-Type": "application/json"
    };
    return import_axios.default.delete(url, { headers: this.enrichHeaders(headers) });
  }
  /**
   * =======
   * SCRIPTS
   *      CONFIG
   * =======
   */
  async getScriptsConfig() {
    const url = `${this.serverUrl}/scripts/config`;
    const headers = {
      "Content-Type": "application/json"
    };
    const response = await import_axios.default.get(url, { headers: this.enrichHeaders(headers) });
    return response.data;
  }
  /**
   * =======
   * SYNCS
   *      GET RECORDS
   *      TRIGGER
   *      START
   *      PAUSE
   *      STATUS
   *      GET ENVIRONMENT VARIABLES
   * =======
   */
  /**
   * @deprecated. Use listRecords() instead.
   */
  async getRecords(config) {
    const { connectionId, providerConfigKey, model, delta, offset, limit, includeNangoMetadata, filter } = config;
    validateSyncRecordConfiguration(config);
    const order = config?.order === "asc" ? "asc" : "desc";
    let sortBy = "id";
    switch (config.sortBy) {
      case "createdAt":
        sortBy = "created_at";
        break;
      case "updatedAt":
        sortBy = "updated_at";
        break;
    }
    if (includeNangoMetadata) {
      console.warn(
        `The includeNangoMetadata option will be deprecated soon and will be removed in a future release. Each record now has a _nango_metadata property which includes the same properties.`
      );
    }
    const includeMetadata = includeNangoMetadata || false;
    const url = `${this.serverUrl}/sync/records/?model=${model}&order=${order}&delta=${delta || ""}&offset=${offset || ""}&limit=${limit || ""}&sort_by=${sortBy || ""}&include_nango_metadata=${includeMetadata}${filter ? `&filter=${filter}` : ""}`;
    const headers = {
      "Connection-Id": connectionId,
      "Provider-Config-Key": providerConfigKey
    };
    const options = {
      headers: this.enrichHeaders(headers)
    };
    const response = await import_axios.default.get(url, options);
    return response.data;
  }
  async listRecords(config) {
    const { connectionId, providerConfigKey, model, delta, modifiedAfter, limit, filter, cursor } = config;
    validateSyncRecordConfiguration(config);
    const url = `${this.serverUrl}/records/?model=${model}${delta ? `&modifiedAfter=${modifiedAfter || delta}` : ""}${limit ? `&limit=${limit}` : ""}${filter ? `&filter=${filter}` : ""}${cursor ? `&cursor=${cursor}` : ""}`;
    const headers = {
      "Connection-Id": connectionId,
      "Provider-Config-Key": providerConfigKey
    };
    const options = {
      headers: this.enrichHeaders(headers)
    };
    const response = await import_axios.default.get(url, options);
    return response.data;
  }
  async triggerSync(providerConfigKey, syncs, connectionId, fullResync) {
    const url = `${this.serverUrl}/sync/trigger`;
    if (typeof syncs === "string") {
      throw new Error("Syncs must be an array of strings. If it is a single sync, please wrap it in an array.");
    }
    const body = {
      syncs: syncs || [],
      provider_config_key: providerConfigKey,
      connection_id: connectionId,
      full_resync: fullResync
    };
    return import_axios.default.post(url, body, { headers: this.enrichHeaders() });
  }
  async startSync(providerConfigKey, syncs, connectionId) {
    if (!providerConfigKey) {
      throw new Error("Provider Config Key is required");
    }
    if (!syncs) {
      throw new Error("Sync is required");
    }
    if (typeof syncs === "string") {
      throw new Error("Syncs must be an array of strings. If it is a single sync, please wrap it in an array.");
    }
    const body = {
      syncs: syncs || [],
      provider_config_key: providerConfigKey,
      connection_id: connectionId
    };
    const url = `${this.serverUrl}/sync/start`;
    return import_axios.default.post(url, body, { headers: this.enrichHeaders() });
  }
  async pauseSync(providerConfigKey, syncs, connectionId) {
    if (!providerConfigKey) {
      throw new Error("Provider Config Key is required");
    }
    if (!syncs) {
      throw new Error("Sync is required");
    }
    if (typeof syncs === "string") {
      throw new Error("Syncs must be an array of strings. If it is a single sync, please wrap it in an array.");
    }
    const url = `${this.serverUrl}/sync/pause`;
    const body = {
      syncs: syncs || [],
      provider_config_key: providerConfigKey,
      connection_id: connectionId
    };
    return import_axios.default.post(url, body, { headers: this.enrichHeaders() });
  }
  async syncStatus(providerConfigKey, syncs, connectionId) {
    if (!providerConfigKey) {
      throw new Error("Provider Config Key is required");
    }
    if (!syncs) {
      throw new Error("Sync is required");
    }
    if (typeof syncs === "string" && syncs !== "*") {
      throw new Error("Syncs must be an array of strings. If it is a single sync, please wrap it in an array.");
    }
    const url = `${this.serverUrl}/sync/status`;
    const params = {
      syncs: syncs === "*" ? "*" : syncs.join(","),
      provider_config_key: providerConfigKey,
      connection_id: connectionId
    };
    const response = await import_axios.default.get(url, { headers: this.enrichHeaders(), params });
    return response.data;
  }
  async updateSyncConnectionFrequency(providerConfigKey, sync, connectionId, frequency) {
    if (!providerConfigKey) {
      throw new Error("Provider Config Key is required");
    }
    if (typeof sync === "string") {
      throw new Error("Sync must be a string.");
    }
    if (typeof connectionId === "string") {
      throw new Error("ConnectionId must be a string.");
    }
    if (typeof frequency !== "string" && frequency !== null) {
      throw new Error("Frequency must be a string or null.");
    }
    const url = `${this.serverUrl}/sync/update-connection-frequency`;
    const params = {
      sync,
      provider_config_key: providerConfigKey,
      connection_id: connectionId,
      frequency
    };
    const response = await import_axios.default.put(url, { headers: this.enrichHeaders(), params });
    return response.data;
  }
  async getEnvironmentVariables() {
    const url = `${this.serverUrl}/environment-variables`;
    const headers = {
      "Content-Type": "application/json"
    };
    const response = await import_axios.default.get(url, { headers: this.enrichHeaders(headers) });
    if (!response.data) {
      return [];
    }
    return response.data;
  }
  /**
   * =======
   * ACTIONS
   *      TRIGGER
   * =======
   */
  async triggerAction(providerConfigKey, connectionId, actionName, input) {
    const url = `${this.serverUrl}/action/trigger`;
    const headers = {
      "Connection-Id": connectionId,
      "Provider-Config-Key": providerConfigKey
    };
    const body = {
      action_name: actionName,
      input
    };
    const response = await import_axios.default.post(url, body, { headers: this.enrichHeaders(headers) });
    return response.data;
  }
  /**
   * =======
   * PROXY
   *      GET
   *      POST
   *      PUT
   *      PATCH
   *      DELETE
   * =======
   */
  async proxy(config) {
    if (!config.connectionId && this.connectionId) {
      config.connectionId = this.connectionId;
    }
    if (!config.providerConfigKey && this.providerConfigKey) {
      config.providerConfigKey = this.providerConfigKey;
    }
    validateProxyConfiguration(config);
    const { providerConfigKey, connectionId, method, retries, headers: customHeaders, baseUrlOverride, decompress, retryOn } = config;
    const url = `${this.serverUrl}/proxy${config.endpoint[0] === "/" ? "" : "/"}${config.endpoint}`;
    const customPrefixedHeaders = customHeaders && Object.keys(customHeaders).length > 0 ? Object.keys(customHeaders).reduce((acc, key) => {
      acc[`Nango-Proxy-${key}`] = customHeaders[key];
      return acc;
    }, {}) : {};
    const headers = {
      "Connection-Id": connectionId,
      "Provider-Config-Key": providerConfigKey,
      "Base-Url-Override": baseUrlOverride || "",
      "Nango-Is-Sync": this.isSync,
      "Nango-Is-Dry-Run": this.dryRun,
      "Nango-Activity-Log-Id": this.activityLogId || "",
      ...customPrefixedHeaders
    };
    if (retries) {
      headers["Retries"] = retries;
    }
    if (decompress) {
      headers["Decompress"] = decompress;
    }
    if (retryOn) {
      headers["Retry-On"] = retryOn.join(",");
    }
    const options = {
      headers: this.enrichHeaders(headers)
    };
    if (config.params) {
      options.params = config.params;
    }
    if (config.paramsSerializer) {
      options.paramsSerializer = config.paramsSerializer;
    }
    if (config.responseType) {
      options.responseType = config.responseType;
    }
    if (this.dryRun) {
      const stringifyParams = (params) => {
        return Object.keys(params).map((key) => `${encodeURIComponent(key)}=${encodeURIComponent(params[key])}`).join("&");
      };
      console.log(
        `Nango Proxy Request: ${method?.toUpperCase()} ${url}${config.params ? `?${stringifyParams(config.params)}` : ""}`
      );
    }
    if (method?.toUpperCase() === "POST") {
      return import_axios.default.post(url, config.data, options);
    } else if (method?.toUpperCase() === "PATCH") {
      return import_axios.default.patch(url, config.data, options);
    } else if (method?.toUpperCase() === "PUT") {
      return import_axios.default.put(url, config.data, options);
    } else if (method?.toUpperCase() === "DELETE") {
      return import_axios.default.delete(url, options);
    } else {
      return import_axios.default.get(url, options);
    }
  }
  async get(config) {
    return this.proxy({
      ...config,
      method: "GET"
    });
  }
  async post(config) {
    return this.proxy({
      ...config,
      method: "POST"
    });
  }
  async patch(config) {
    return this.proxy({
      ...config,
      method: "PATCH"
    });
  }
  async delete(config) {
    return this.proxy({
      ...config,
      method: "DELETE"
    });
  }
  async getConnectionDetails(providerConfigKey, connectionId, forceRefresh = false, refreshToken = false, additionalHeader = {}) {
    const url = `${this.serverUrl}/connection/${connectionId}`;
    const headers = {
      "Content-Type": "application/json",
      "Nango-Is-Sync": this.isSync,
      "Nango-Is-Dry-Run": this.dryRun
    };
    if (additionalHeader) {
      Object.assign(headers, additionalHeader);
    }
    const params = {
      provider_config_key: providerConfigKey,
      force_refresh: forceRefresh,
      refresh_token: refreshToken
    };
    return import_axios.default.get(url, { params, headers: this.enrichHeaders(headers) });
  }
  async listConnectionDetails(connectionId) {
    let url = `${this.serverUrl}/connection?`;
    if (connectionId) {
      url = url.concat(`connectionId=${connectionId}`);
    }
    const headers = {
      "Content-Type": "application/json"
    };
    return import_axios.default.get(url, { headers: this.enrichHeaders(headers) });
  }
  enrichHeaders(headers = {}) {
    headers["Authorization"] = "Bearer " + this.secretKey;
    return headers;
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AuthModes,
  Nango,
  SyncConfigType,
  SyncType,
  prodHost,
  stagingHost
});
